<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>MMO Client</title>
    <link rel="preload" as="image" href="world.jpg">
    <link rel="stylesheet" href="/styles.css">
  </head>
  <body>
    <canvas id="world-canvas"></canvas>

    <script>
      (function() {
        const canvas = document.getElementById('world-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const WS_URL = 'wss://codepath-mmorg.onrender.com';

        const state = {
          ws: null,
          playerId: null,
          players: {},
          avatars: {},
          avatarBitmaps: {}, // avatarName -> { north: ImageBitmap[], south: ImageBitmap[], east: ImageBitmap[] }
          world: {
            image: null,
            width: 0,
            height: 0
          },
          destMarker: null // { x, y, t0, ttlMs }
        };

        let needsRender = false;

        // Size the canvas to fill the window (CSS pixels)
        function resizeCanvasToDisplaySize() {
          const displayWidth = Math.floor(window.innerWidth);
          const displayHeight = Math.floor(window.innerHeight);
          if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
            canvas.width = displayWidth;
            canvas.height = displayHeight;
          }
          canvas.style.width = '100vw';
          canvas.style.height = '100vh';
          ctx.imageSmoothingEnabled = false;
          requestRender();
        }

        const worldImage = new Image();
        worldImage.src = 'world.jpg';
        worldImage.decoding = 'async';
        worldImage.addEventListener('load', () => {
          state.world.image = worldImage;
          state.world.width = worldImage.naturalWidth;
          state.world.height = worldImage.naturalHeight;
          requestRender();
        });

        function clear() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function requestRender() {
          if (needsRender) return;
          needsRender = true;
          requestAnimationFrame(() => {
            needsRender = false;
            render();
          });
        }

        function connect() {
          const ws = new WebSocket(WS_URL);
          state.ws = ws;
          ws.addEventListener('open', () => {
            ws.send(JSON.stringify({ action: 'join_game', username: 'Tim' }));
          });
          ws.addEventListener('message', onMessage);
        }

        async function onMessage(event) {
          let data;
          try {
            data = JSON.parse(event.data);
          } catch (e) {
            return;
          }
          if (data.action === 'join_game' && data.success) {
            state.playerId = data.playerId;
            state.players = data.players || {};
            state.avatars = data.avatars || {};
            // Ensure avatars for any players we know about
            const avatarEnsures = [];
            for (const pid in state.players) {
              const p = state.players[pid];
              if (p && p.avatar && state.avatars[p.avatar]) {
                avatarEnsures.push(ensureAvatarBitmaps(p.avatar, state.avatars[p.avatar]));
              }
            }
            if (avatarEnsures.length) await Promise.all(avatarEnsures);
            requestRender();
          } else if (data.action === 'players_moved' && data.players) {
            // Merge movement updates for all players
            for (const pid in data.players) {
              const update = data.players[pid];
              if (!update) continue;
              const existing = state.players[pid] || { id: pid };
              state.players[pid] = { ...existing, ...update };
            }
            requestRender();
          } else if (data.action === 'player_joined' && data.player) {
            const p = data.player;
            state.players[p.id] = p;
            if (data.avatar && data.avatar.name) {
              state.avatars[data.avatar.name] = data.avatar;
              await ensureAvatarBitmaps(data.avatar.name, data.avatar);
            }
            requestRender();
          } else if (data.action === 'player_left' && data.playerId) {
            delete state.players[data.playerId];
            requestRender();
          }
        }

        async function ensureAvatarBitmaps(avatarName, avatarDef) {
          if (state.avatarBitmaps[avatarName]) return state.avatarBitmaps[avatarName];
          const result = { north: [], south: [], east: [] };
          const dirs = ['north', 'south', 'east'];
          for (const dir of dirs) {
            const frames = (avatarDef.frames && avatarDef.frames[dir]) || [];
            const bitmaps = await Promise.all(frames.map(decodeToBitmap));
            result[dir] = bitmaps.filter(Boolean);
          }
          state.avatarBitmaps[avatarName] = result;
          return result;
        }

        // Ensure we have bitmaps for a player's avatar when drawing
        async function ensurePlayerAvatarLoaded(player) {
          if (!player || !player.avatar) return;
          const avatarName = player.avatar;
          if (state.avatarBitmaps[avatarName]) return;
          const def = state.avatars[avatarName];
          if (def) {
            await ensureAvatarBitmaps(avatarName, def);
            requestRender();
          }
        }

        async function decodeToBitmap(dataUrl) {
          try {
            const res = await fetch(dataUrl);
            const blob = await res.blob();
            const bmp = await createImageBitmap(blob);
            return bmp;
          } catch (e) {
            return null;
          }
        }

        function computeCamera() {
          const me = state.players[state.playerId];
          const worldW = state.world.width || 0;
          const worldH = state.world.height || 0;
          const viewW = canvas.width;
          const viewH = canvas.height;
          if (!me || !worldW || !worldH || !viewW || !viewH) {
            return { x: 0, y: 0 };
          }
          const desiredX = Math.round(me.x - viewW / 2);
          const desiredY = Math.round(me.y - viewH / 2);
          const maxX = Math.max(0, worldW - viewW);
          const maxY = Math.max(0, worldH - viewH);
          const camX = Math.max(0, Math.min(maxX, desiredX));
          const camY = Math.max(0, Math.min(maxY, desiredY));
          return { x: camX, y: camY };
        }

        function drawWorld(camera) {
          if (!state.world.image) return;
          const sx = camera.x;
          const sy = camera.y;
          const sWidth = Math.min(canvas.width, state.world.width - sx);
          const sHeight = Math.min(canvas.height, state.world.height - sy);
          clear();
          ctx.drawImage(state.world.image, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        }

        function drawPlayer(player, camera) {
          if (!player || !player.avatar) return;
          const atlas = state.avatarBitmaps[player.avatar];
          if (!atlas) {
            // Attempt lazy-load of this avatar, then re-render when ready
            ensurePlayerAvatarLoaded(player);
            return;
          }
          let facing = player.facing || 'south';
          let frames = atlas[facing];
          let flippedWest = false;
          if (!frames || frames.length === 0) {
            if (facing === 'west') {
              frames = atlas['east'];
              flippedWest = true;
            } else {
              frames = atlas['south'] || [];
            }
          }
          if (!frames || frames.length === 0) return;
          const frameIndex = Math.max(0, (player.animationFrame || 0) % frames.length);
          const bmp = frames[frameIndex];
          if (!bmp) return;

          const screenX = Math.round(player.x - camera.x);
          const screenY = Math.round(player.y - camera.y);
          const drawW = bmp.width;
          const drawH = bmp.height;
          const dx = Math.round(screenX - drawW / 2);
          const dy = Math.round(screenY - drawH / 2);

          ctx.save();
          if (facing === 'west' || flippedWest) {
            ctx.translate(screenX, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(bmp, -Math.round(drawW / 2), dy);
          } else {
            ctx.drawImage(bmp, dx, dy);
          }
          ctx.restore();

          drawLabel(player.username || 'Player', screenX, dy - 6);
        }

        function drawLabel(text, centerX, bottomY) {
          const paddingX = 6;
          const paddingY = 3;
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          const metrics = ctx.measureText(text);
          const labelW = Math.ceil(metrics.width) + paddingX * 2;
          const labelH = 16 + paddingY * 2;
          const x = Math.round(centerX - labelW / 2);
          const y = Math.round(bottomY - labelH);
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(x, y, labelW, labelH);
          ctx.fillStyle = '#fff';
          ctx.fillText(text, Math.round(centerX), Math.round(bottomY - paddingY));
        }

        function drawDestinationMarker(camera) {
          const marker = state.destMarker;
          if (!marker) return;
          const now = performance.now();
          const age = now - marker.t0;
          const ttl = marker.ttlMs || 1000;
          if (age >= ttl) {
            state.destMarker = null;
            return;
          }
          const alpha = 1 - age / ttl;
          const pulse = 8 + Math.sin(age / 80) * 4;
          const screenX = Math.round(marker.x - camera.x);
          const screenY = Math.round(marker.y - camera.y);
          ctx.save();
          ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
          ctx.lineWidth = 2;
          ctx.strokeStyle = '#ffd54f';
          ctx.beginPath();
          ctx.arc(screenX, screenY, pulse, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(screenX - pulse - 4, screenY);
          ctx.lineTo(screenX - 2, screenY);
          ctx.moveTo(screenX + 2, screenY);
          ctx.lineTo(screenX + pulse + 4, screenY);
          ctx.moveTo(screenX, screenY - pulse - 4);
          ctx.lineTo(screenX, screenY - 2);
          ctx.moveTo(screenX, screenY + 2);
          ctx.lineTo(screenX, screenY + pulse + 4);
          ctx.stroke();
          ctx.restore();
        }

        function render() {
          const camera = computeCamera();
          drawWorld(camera);
          // Draw all players depth-sorted by y for simple occlusion
          const list = Object.values(state.players || {});
          list.sort((a, b) => (a.y || 0) - (b.y || 0));
          for (const p of list) {
            drawPlayer(p, camera);
          }
          // Draw destination marker on top
          drawDestinationMarker(camera);
          // Keep animating the marker while it fades
          if (state.destMarker) requestRender();
        }

        // Redraw on resize to keep canvas matched to viewport.
        window.addEventListener('resize', resizeCanvasToDisplaySize);

        // Keyboard controls: send one move message per keydown (including auto-repeat)
        const KEY_TO_DIRECTION = {
          ArrowUp: 'up',
          ArrowDown: 'down',
          ArrowLeft: 'left',
          ArrowRight: 'right'
        };

        function sendMove(direction) {
          if (!direction) return;
          const ws = state.ws;
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ action: 'move', direction }));
          }
        }

        function sendMoveTo(x, y) {
          if (typeof x !== 'number' || typeof y !== 'number') return;
          const ws = state.ws;
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ action: 'move', x: Math.round(x), y: Math.round(y) }));
          }
        }

        window.addEventListener('keydown', (event) => {
          const direction = KEY_TO_DIRECTION[event.key];
          if (!direction) return;
          event.preventDefault();
          sendMove(direction);
        });

        // Click-to-move: translate screen coords to world coords and send
        canvas.addEventListener('click', (event) => {
          const rect = canvas.getBoundingClientRect();
          const clickX = Math.round(event.clientX - rect.left);
          const clickY = Math.round(event.clientY - rect.top);
          const camera = computeCamera();
          const worldX = (camera.x || 0) + clickX;
          const worldY = (camera.y || 0) + clickY;
          state.destMarker = { x: worldX, y: worldY, t0: performance.now(), ttlMs: 1000 };
          sendMoveTo(worldX, worldY);
          requestRender();
        });

        // Initialize
        resizeCanvasToDisplaySize();
        connect();
      })();
    </script>
  </body>
  </html>

